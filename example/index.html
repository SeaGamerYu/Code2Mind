<!DOCTYPE html>
<html>
<head>
  <title></title>
  <meta charset="utf-8">
  <style>
    * {
      margin: 0 0;
      padding: 0 0;
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
    }

    textarea {
      margin: 0 auto;
      height: 300px;
      width: 100%;
      resize: none;
      padding: 5px 10px;
      font-size: 16px;
    }

    .input-warp {
      width: 500px;
      position: absolute;
      top: 20px;
      left: 20px;
      background: #FFFFFF;
      z-index: 1000;
    }

    .content-warp {
      position: fixed;
      overflow: auto;
      height: 100%;
      background: #f2f2f2;
      width: 100%;
    }

    .content-warp::-webkit-scrollbar {
      width: 0;
      height: 0;
    }

    .svg-warp {
      position: relative;
      width: 20000px;
      height: 20000px;

    }

    .code2mind-main {
      position: absolute;
      padding: 10px 50px;
      line-height: 22px;
      min-height: 40px;
      color: #FFFFFF;
      border-radius: 50%;
      max-width: 300px;
      word-wrap: break-word;
      white-space: pre-wrap;
      word-break: break-word;
      text-align: left;
      background: #fa815e;
      will-change: top, left;
    }

    .code2mind-main-item {
      border-radius: 4px;
      padding: 10px 20px;
    }

    .code2mind-main-item2 {
      background: transparent;
      border-radius: 0;
      color: #999999;
      border-bottom: 2px solid #999999;
    }
  </style>
</head>
<body>
<div class="input-warp">
  <textarea title="" id="text" placeholder="请输入"></textarea>
</div>
<div class="content-warp">
  <div id="svgcontent" class="svg-warp">

  </div>
</div>
<script src="../dist/code2mind.js"></script>
<script>
const text = document.getElementById('text');
const svgcontent = document.getElementById('svgcontent');

const config = {
  heightSpac: 50,
  widthSpac: 100,
};

handler(text.value);
text.addEventListener('blur', () => {
  handler(text.value);
});
text.addEventListener('keydown', (e) => {
  if (e.code === 'Tab') {
    e.preventDefault();
  }
});
text.addEventListener('keyup', (e) => {
  if (e.code === 'Tab') {
    e.preventDefault();
    const currentEl = e.target;
    const startAt = currentEl.selectionStart;
    currentEl.value = currentEl.value.substring(0, startAt) + '  ' + currentEl.value.substring(startAt);
    currentEl.selectionStart = startAt + 2;
    currentEl.selectionEnd = startAt + 2;
  }
});
const height = svgcontent.offsetHeight;
const width = svgcontent.offsetWidth;
const px = (width - svgcontent.parentElement.offsetWidth) / 2;
const ph = (height - svgcontent.parentElement.offsetHeight) / 2;
svgcontent.parentElement.scrollTo(px, ph);

function handler (value) {
  if (value) {
    const result = Code2Mind.parse(value);
    svgcontent.innerHTML = '';
    const cloneSvg = svgcontent.cloneNode(true);
    cloneSvg.style.zIndex = '-9000';
    cloneSvg.style.visibility = 'hidden';
    document.body.appendChild(cloneSvg);
    calcBound(cloneSvg, result);
    document.body.removeChild(cloneSvg);
    layout(result, width / 2 - result.bound.width / 2, height / 2 - result.bound.height / 2);
    drawMind(svgcontent, result);
  }
}

function drawMind (svgcontent, data) {
  const div = document.createElement('div');
  let className = 'code2mind-main';
  if (data.level > 0) {
    className += ' code2mind-main-item';
  }
  if (data.level > 1) {
    className += ' code2mind-main-item2';
  }
  div.className = className;
  div.innerText = data.title;
  div.style.top = data.top + 'px';
  div.style.left = data.left + 'px';
  if (data.children.length) {
    data.children.forEach((item) => {
      drawMind(svgcontent, item);
    });
  }
  svgcontent.appendChild(div);
}

function layout (data, x, y, isLeft) {
  // let w = x + config.widthSpac + data.bound.width;
  const len = data.children.length;
  if (len) {
    if (data.level === 0) {
      let leftY = y + data.bound.height / 2 - data.bound.clientHeight.leftH / 2;
      let rightY = y + data.bound.height / 2 - data.bound.clientHeight.rightH / 2;
      data.children.forEach((item, idx) => {
        if (item.isLeft) {
          let w = x - config.widthSpac - item.bound.width;
          leftY += idx / 2 === 0 ? 0 : (data.children[idx - 2].bound.clientHeight + config.heightSpac);
          layout(item, w, leftY, true);
        } else if (item.isRight) {
          let w = x + config.widthSpac + data.bound.width;
          rightY += (idx - 1) / 2 === 0 ? 0 : (data.children[idx - 2].bound.clientHeight + config.heightSpac);
          layout(item, w, rightY);
        }
      });
    } else {
      let w = x + config.widthSpac + data.bound.width;
      if (isLeft) {
        w = x - config.widthSpac - data.bound.width;
      }
      let h = y + data.bound.height / 2 - data.bound.clientHeight / 2;
      if (data.level === 1) {
        h -= data.bound.height / 2;
      }
      data.children.forEach((item, idx) => {
        h += (idx === 0 ? 0 : data.children[idx - 1].bound.clientHeight) + (idx === 0 ? 0 : config.heightSpac);
        layout(item, w, h, isLeft);
      });
    }
    // let h = y + data.bound.height / 2 - data.bound.clientHeight / 2;
    // let leftY = y + data.bound.height / 2 - data.bound.clientHeight.leftH / 2;
    // let rightY = y + data.bound.height / 2 - data.bound.clientHeight.rightH / 2;
    // data.children.forEach((item, idx) => {
    //   let w = currentW;
    //   if (data.level === 0 && item.isLeft) {
    //     w = x - config.widthSpac - item.bound.width;
    //     leftY += (idx / 2 === 0 ? 0 : data.children[idx - 1].bound.clientHeight) + (idx / 2 === 0 ? 0 : config.heightSpac);
    //     layout(item, w, leftY, true);
    //   } else if (data.level === 0 && item.isRight) {
    //     rightY += ((idx - 1) / 2 === 0 ? 0 : data.children[idx - 1].bound.clientHeight) + ((idx - 1) / 2 === 0 ? 0 : config.heightSpac);
    //     layout(item, w, rightY);
    //   } else if (isLeft) {
    //     w = x - config.widthSpac - item.bound.width;
    //     h += (idx === 0 ? 0 : data.children[idx - 1].bound.clientHeight) + (idx === 0 ? 0 : config.heightSpac);
    //     layout(item, w, h, isLeft);
    //   } else {
    //     h += (idx === 0 ? 0 : data.children[idx - 1].bound.clientHeight) + (idx === 0 ? 0 : config.heightSpac);
    //     layout(item, w, h);
    //   }
    // });
  }
  data.top = y;
  data.left = x;

}

function calcBound (cloneSvg, data) {
  const bound = {
    clientWidth: 0,
    clientHeight: 0,
    width: 0,
    height: 0,
  };
  const div = document.createElement('div');
  let className = 'code2mind-main';
  if (data.level > 0) {
    className += ' code2mind-main-item';
  }
  if (data.level > 1) {
    className += ' code2mind-main-item2';
  }
  div.className = className;

  div.innerText = data.title;
  // 计算宽度和高度
  cloneSvg.appendChild(div);
  bound.clientWidth = bound.width = div.offsetWidth;
  bound.clientHeight = bound.height = div.offsetHeight;
  const len = data.children.length;
  if (len) {
    let w = 0;
    let h = 0;
    let leftH = 0;
    let rightH = 0;
    let leftW = 0;
    let rightW = 0;
    data.children.forEach((item, index) => {
      calcBound(cloneSvg, item);
      if (data.level === 0) {
        if (index % 2 === 0) {
          item.isLeft = true;
          leftH += item.bound.clientHeight + config.heightSpac;
          leftW += item.bound.clientWidth;
        } else {
          item.isRight = true;
          rightH += item.bound.clientHeight + config.heightSpac;
          rightW += item.bound.clientWidth;
        }
      } else {
        h += item.bound.clientHeight;
        if (item.bound.clientWidth > w) {
          w = item.bound.clientWidth;
        }
      }
    });
    if (data.level === 0) {
      leftH = leftH - config.heightSpac;
      leftH = (leftH > bound.clientHeight ? leftH : bound.clientHeight);
      rightH = rightH - config.heightSpac;
      rightH = (rightH > bound.clientHeight ? rightH : bound.clientHeight);
      bound.clientHeight = {
        leftH,
        rightH,
      };
      bound.clientWidth = {
        leftW,
        rightW,
        w: leftW + rightW + bound.clientWidth + config.widthSpac * 2,
      };
    } else {
      h += (len - 1) * config.heightSpac;
      h = (h > bound.clientHeight ? h : bound.clientHeight);
      w += bound.clientWidth + config.widthSpac;
      bound.clientWidth = w;
      bound.clientHeight = h;
    }
  }
  data.bound = bound;
}


function setAttrs (el, option) {
  const keys = Object.keys(option);
  keys.forEach((item) => {
    el.setAttribute(item, option[item]);
  });
}

function createdSvgEl (tag, option) {
  const tagEl = document.createElementNS('http://www.w3.org/2000/svg', tag);
  setAttrs(tagEl, option);
  return tagEl;
}

//
// list.forEach(({ x, y }) => {
//   const circle = createdSvgEl('circle', {
//     cx: x,
//     cy: y,
//     r: 10,
//   });
//   // const text = createdSvgEl('text', {
//   //   x,
//   //   y,
//   // });
//   // text.innerHTML = title;
//   g.append(circle);
// });
// let start = { x: 0, y: 0 };
// list.forEach(({ x, y }, index) => {
//   if (index === 0) {
//     start = {
//       x, y,
//     };
//   } else {
//     const d = `M ${start.x} ${start.y} Q 350 400 ${x} ${y}`;
//     const path = createdSvgEl('path', {
//       d,
//       stroke: 'blue',
//       'stroke-width': '5',
//       fill: 'none',
//     });
//     svg.append(path);
//   }
// });
//
//
// svg.append(g);
// document.body.appendChild(svg);
</script>

</body>
</html>
